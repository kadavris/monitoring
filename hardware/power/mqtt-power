#!/usr/bin/env python3
"""
 This script produces reports on electrical power and push it into mqtt.
 repo is in github.com/kadavris.
 assumed topic structure:
     power
         <dev_id> - {"model":"...", "errors":"...", "attribute1":"..."...}
            state_topic... - one-line state message
            updated - JSON: { "date":"human-readable date", timestamp:UNIXTS }
"""
import argparse
import configparser
from configparser import ConfigParser, SectionProxy
import os
import os.path
import re
import signal
import socket
import sys
import subprocess
import time
from kadpy.kbattlead import KBattLead
from kadpy.kmqtt import KMQTT

# globals and prototypes to shut IDE up
DEFAULT_CONFIG_PATH = '/etc/smarthome/monitoring/power/'
DEFAULT_CONFIG_FILE = DEFAULT_CONFIG_PATH + 'mqtt-power.ini'
GLOBAL_CONFIG: ConfigParser = configparser.ConfigParser(interpolation=configparser.ExtendedInterpolation())
CONFIG: SectionProxy
Sender: KMQTT
DEVICES: dict = {} # will hold device's current data for continuous processing and statistics

#############################################################
def handle_termination(signum, frame) -> None:
    """
    Will (safely) handle termination. Stopping sender agent on its rails.
    :param signum: NOT USED
    :param frame: ALSO NOT USED
    :return: None
    """
    if ARGS.debug:
        print("! signal caught. exiting.", file=sys.stderr)

    if Sender:
        Sender.terminate()

    # todo: close logs and stats
    sys.exit(0)


#############################################################
def load_config(c_file: str):
    """
    Will load configuration file, checking for problems beforehand
    :param c_file: path to config file
    :return: parsed config section object
    """
    global ARGS, GLOBAL_CONFIG

    file = c_file

    if not os.path.exists(file):
        if '/' in file:
            print("! Can't open config: ", file, file=sys.stderr)
            sys.exit(1)

        file = DEFAULT_CONFIG_PATH + c_file

    if ARGS.debug:
        print("+ Loading config:", file)

    GLOBAL_CONFIG.read(file)
    if GLOBAL_CONFIG.has_section('power'):
        return GLOBAL_CONFIG['power']

    print("! 'No 'power' section found in config file:", file, file=sys.stderr)
    sys.exit(1)


########################################
def update_vf_stats(device: str, prefix: str, time_value: int, voltage: float, freq: float) -> None:
    """
    Will update stats[ device ] with per-minute, hourly or daily values depending on a prefix value.
    All keys in form prefix + 'string' must be in sync with outer function for values to be reported successfully
    :param device: str: device path
    :param prefix: str: 'm'/'h'/'d' - time fraction unit
    :param time_value: int: time part value that we're accounting for
    :param voltage: float: as reported by device
    :param freq: float: frequency as reportde by device
    :return: None
    """
    global stats_vf

    ds = stats_vf[device]
    if ds[prefix + 'start'] != time_value:  # new time period?
        # making old mean the 1st value of this period
        ds[prefix + 'samples'] = 1 if ds[prefix + '_v_mean'] > 0 else 0
        if voltage > 0.0:
            ds[prefix + 'samples'] += 1
        ds[prefix + 'v'] = ds[prefix + '_v_mean'] + int(voltage)
        ds[prefix + 'f'] = ds[prefix + '_f_mean'] + int(freq)
        ds[prefix + 'start'] = time_value

        if prefix == 'd':  # reset blackouts info. Later we may switch to 'last 24 hours'
            ds['bo_time'] = 0
            ds['blackouts'] = 0
            ds['in_bo'] = False
    else:  # same period
        if voltage > 0.0:  # don't account for blackouts from russian cultural bombings.
            ds[prefix + 'samples'] += 1
            ds[prefix + 'v'] += voltage
            ds[prefix + 'f'] += freq

    # Managing blackouts info
    if voltage > 0.0:
        ds['in_bo'] = False
    else:
        if prefix == 'd':  # update blackouts once per m/h/d calls series
            ds['bo_time'] += int(CONFIG['sample_interval'])
            if not ds['in_bo']:
                ds['blackouts'] += 1
                ds['in_bo'] = True

    # updating mean values
    if ds[prefix + 'samples'] != 0:
        ds[prefix + '_v_mean'] = ds[prefix + 'v'] // ds[prefix + 'samples']
        ds[prefix + '_f_mean'] = ds[prefix + 'f'] // ds[prefix + 'samples']


########################################
def get_model_specific_config(device: str, keyword: str, default: str = "") -> str:
    """
    Return the value of model-specific setting from config.
    :param device: str. NUT's ID of UPS device
    :param keyword: str. Attribute/keyword name
    :param default: str. Default value to return if not found
    :return: str. The value
    """
    global CONFIG, GLOBAL_CONFIG

    specific_section = "power." + device
    if specific_section in GLOBAL_CONFIG \
            and keyword in GLOBAL_CONFIG[specific_section]:
        return GLOBAL_CONFIG[specific_section][keyword]

    if keyword in CONFIG:  # check if config has default of its own
        return CONFIG[keyword]

    return default


########################################
def get_data_from_upsc(device: str) -> dict:
    """
    Collects data from upsc output for given device.
    :param device:
    :return: dict("model":"manufacturer model", "data":dict(attribute:val))
    """
    global ARGS, CONFIG, DEVICES, stats_vf

    to_return = {"model": "", "errors": "",
                 "data": {},  # attributes values will be here
    }

    # initializing the list of minimal attributes that we needed (note '.' replaced by '_')
    upsc_data_needed = [
        'device_mfr',  # device.mfr: EATON
        'device_model',  # device.model: 5E 1500i
        'device_type',  # device.type: ups
        'ups_status',  # ups.status: OL
    ]

    dev_data = DEVICES[device]
    # adding user-defined properties
    if 'one_to_one' in CONFIG:
        for pair in CONFIG.get('one_to_one').split():
            oto_attr, oto_topic = pair.split(':')
            upsc_data_needed.append(oto_attr)

    if 'bulk_report' in dev_data:
        to_return['bulk_report'] = dev_data['bulk_report']
        upsc_data_needed += to_return['bulk_report']

    to_return['need'] = upsc_data_needed  # indicating what we intended to collect here

    upsc_bin = ['upsc', device]
    if 'upsc_binary' in CONFIG:
        upsc_bin = CONFIG.get('upsc_binary').replace('$device', device).split()

    upsc = subprocess.Popen(upsc_bin,
                            stdin=subprocess.DEVNULL, stdout=subprocess.PIPE,
                            stderr=(None if ARGS.debug else subprocess.DEVNULL), text=True)

    if upsc.poll():
        if upsc.returncode > 0:
            to_return["errors"] = '"upsc error":"ended with rc: ' + str(upsc.returncode) + '"'
            print(to_return["errors"])
        return to_return

    out, err = upsc.communicate()  # communicate() will return all output at once

    if err and (err != ''):
        to_return["errors"] = '"upsc error":"' + err + "'"
        print(to_return["errors"])
        return to_return

    for report_line in out.splitlines():
        # attributes array?
        rm = re.match(r'([\w.]+):\s+(.+)', report_line)
        if not rm:
            continue

        attribute_name = rm.group(1).replace('.', '_')
        value = rm.group(2).strip()

        if attribute_name not in upsc_data_needed:
            continue

        to_return['data'][attribute_name] = value

    # do some stats
    try:
        t = time.localtime()

        v = float(to_return['data']['input_voltage'])
        f = float(to_return['data']['input_frequency']) \
            if 'input_frequency' in to_return['data'] else 0.0
        if f == 0.0:
            f = float(to_return['data']['output_frequency']) \
                if 'output_frequency' in to_return['data'] else 0.0

        if device not in stats_vf:  # init
            stats_vf[device] = {
                'blackouts': 0, 'bo_time': 0, 'in_bo': False,
                'mstart': 0, 'm_v_mean': 0, 'mv': 0.0,  # minute
                'mf': 0, 'm_f_mean': 0, 'msamples': 0,
                'hstart': 0, 'h_v_mean': 0, 'hv': 0.0,  # hour
                'hf': 0, 'h_f_mean': 0, 'hsamples': 0,
                'dstart': 0, 'd_v_mean': 0, 'dv': 0.0,  # day
                'df': 0, 'd_f_mean': 0, 'dsamples': 0
            }

        update_vf_stats(device, 'm', t.tm_min, v, f)
        update_vf_stats(device, 'h', t.tm_hour, v, f)
        update_vf_stats(device, 'd', t.tm_mday, v, f)

        to_return['data']['voltage_mean_minute'] = stats_vf[device]['m_v_mean']
        to_return['data']['frequency_mean_minute'] = stats_vf[device]['m_f_mean']

        to_return['data']['voltage_mean_hour'] = stats_vf[device]['h_v_mean']
        to_return['data']['frequency_mean_hour'] = stats_vf[device]['h_f_mean']

        to_return['data']['voltage_mean_day'] = stats_vf[device]['d_v_mean']
        to_return['data']['frequency_mean_day'] = stats_vf[device]['d_f_mean']

        to_return['data']['blackouts'] = stats_vf[device]['blackouts']
        to_return['data']['time_in_blackouts'] = stats_vf[device]['bo_time']
    except Exception:
        pass

    # fill in specials:
    # device.mfr: EATON. Some UPS report empty string here
    if 'device_mfr' in to_return['data'] and to_return['data']['device_mfr'] != "":
        to_return['model'] = to_return['data']['device_mfr']
    else:
        to_return['model'] = get_model_specific_config(device, ".mfr", "UNSPECIFIED MFR")

    # device.model: 5E 1500i
    if 'device_model' in to_return['data'] and to_return['data']['device_model']:
        to_return['model'] += ' ' + to_return['data']['device_model']
    else:
        to_return['model'] += ' ' + get_model_specific_config(device, ".model", "")

    return to_return


########################################
def device_init(device: str) -> bool:
    """
    Prepares device data sourced from configuration file.
    :param device: str: device ID
    :return: bool: success
    """
    global CONFIG, DEVICES, GLOBAL_CONFIG
    dd = DEVICES[device] = {
        'dev_id': device,
        'sample_interval': int(CONFIG['sample_interval']),
    }

    csect_name = 'power.' + device
    if csect_name in GLOBAL_CONFIG:
        csect = GLOBAL_CONFIG[csect_name]
    else:
        csect = {}

    problems = []  # will hold an itemized list of any problems encountered
    binfo = csect['battery'].split(',')  #'battery=<type>,<nominal voltage>,<pack's A/h>'
    if len(binfo) != 2 or binfo[0].lower() not in ['pb','lifepo'] \
        or not binfo[1].isdigit() or not binfo[2].isdigit() \
        or int(binfo[1]) % 12 != 0 or int(binfo[1]) < 12 or int(binfo[2]) < 1:
         problems.append('Battery definition error')
    else:
        dd['batt_type'] = binfo[0]
        dd['batt_vnom'] = int(binfo[1])
        dd['batt_cap'] = int(binfo[2])

    if -1 == dd['power_rating'].find(','):
        pr = dd['power_rating']
        unit = 'va'
    else:
        pr, unit = dd['power_rating'].split(',')

    if not pr.isdigit() or int(pr) < 100 or unit not in ['va', 'w']:
        problems.append("Invalid power rating def")
    else:
        dd['power_rating'] = float(pr)
        dd['power_rating_unit'] = unit

    if 'load_reported_as' in csect:
        unit = dd['load_reported_as'].lower()
    else:
        unit = 'p'

    if unit[0] not in 'pvw':
        problems.append("Invalid load_reported_as def")
    else:
        dd['load_reported_as'] = unit[0]

    dd['calc_charge_data'] = bool(csect['calc_charge_data']) if 'calc_charge_data' in csect else False

    # list() options that may override common config:
    for overrides in ['one_to_one', 'bulk_report', 'log_items']:
        option = get_model_specific_config(device, overrides)
        if option:
            dd[overrides] = option.split()

    if problems:
        print(f'Device {device} has problems: {problems}', file=sys.stderr)
        return False

    ps = get_model_specific_config(device, 'perma_storage', '')
    if dd['batt_type'] == 'pb':  # if path is empty, the load/save will silently fail
        dd['statobj'] = KBattLead(ps, dd)

    return True


########################################
def check_nut() -> bool:
    """
    Will analyze upsc output and send the data to MQTT.
    Default function to run on invocation of this script.
    :return: bool - False in case of trouble
    """
    global ARGS, CONFIG, DEVICES, log_items, Sender, stats_vf

    for device in DEVICES:
        dev_topic = CONFIG['device_topic'].replace('$device', device)

        if ARGS.debug:
            print('device:', device, 'topic:', dev_topic)

        upsc_data = get_data_from_upsc(device)

        # we will count the configured checks to report if none were enabled actually
        checks_run = 0
        checks_with_errors = 0

        # this will be sent last and be updated by other analysis code on the way
        bulk_msg = '{ "model":"' + upsc_data['model'] + '", "errors":"' + upsc_data["errors"] + '"'

        for k in upsc_data['data']:
            bulk_msg += ', "' + k + '":"' + str(upsc_data['data'][k]) + '"'

        bulk_msg += ' }'

        # --------------------------------
        if 'log_samples' in CONFIG:
            log_name = CONFIG['log_samples'].replace('$device', device)
            try:
                time_str = time.strftime(r'%Y-%m-%d %H:%M:%S')

                line = ''
                if len(log_items) > 0:  # a subset of data requested
                    for k in log_items:
                        if k and k not in upsc_data['data']:
                            line += time_str + ' WARNING! upsc does not provide item "' + k + '"\n'
                            log_items[log_items.index(k)] = None

                    line += time_str + ' { "date":"' + time_str + '"'

                    for k in log_items:
                        if k:
                            line += ', "' + k + '":"' + str(upsc_data['data'][k]) + '"'

                    line += ' }\n'

                else:  # just log anything that we've got
                    line = time_str + bulk_msg.replace('\n', ' ') + '\n'

                open(log_name, mode='a').writelines(line)

            except Exception:
                del CONFIG['log_samples']
                print('! Error writing log file: ', log_name, ':',
                      sys.exc_info()[0], file=sys.stderr)
        # if 'log_samples' in config

        # is it time to post new data?
        next_rep = device + '_next_report'

        if (next_rep in stats_vf) and stats_vf[next_rep] > time.time():  # too soon to report?
            continue

        stats_vf[next_rep] = time.time() + float(CONFIG['report_interval'])

        # quick post one-to-one data
        if 'one_to_one' in CONFIG:
            for pair in CONFIG.get('one_to_one').split():
                oto_attr, oto_topic = pair.split(':')
                checks_run += 1

                if oto_attr in upsc_data['data']:
                    msg = upsc_data['data'][oto_attr]
                else:
                    if oto_attr in ['ups_alarm']:
                        msg = 'OK'
                    else:
                        msg = 'NO DATA'
                        checks_with_errors += 1

                Sender.send_json_short(dev_topic + '/' + oto_topic, msg, retain=True)

        # finally sending general status message
        if upsc_data['errors'] != '' or ('ups_status' not in upsc_data['data']):
            msg = upsc_data['errors']
            checks_with_errors += 1
        else:
            msg = upsc_data['data']['ups_status']
        checks_run += 1

        DEVICES[device]['statobj'].update_stats(upsc_data)

        Sender.send_json_short(dev_topic + '/' + CONFIG['state_topic'], msg, retain=True)

        # sending time stats
        Sender.send_json_short(dev_topic + '/' + CONFIG['updated_topic'], Dates_json, retain=True)

        # doing bulk report message. we'll use 'mpublish' posting method, so no quoting is needed
        stop_word = '25@5h256h256H'
        bulk_msg = bulk_msg[:-1] + ', "checks run":' + str(checks_run) + \
            ', "checks with errors":' + str(checks_with_errors) + ' }'

        Sender.send_json_long(dev_topic, bulk_msg, retain=True, stop_word=stop_word)

    # end loop: for device in list
    return True


####################################################
# MAIN
parser = argparse.ArgumentParser(
    description='Collecting power supply info and passing it to mqtt agent. V2.6.1.'
                ' Created by Andrej Pakhutin - pakhutin at gmail.'
    )
parser.add_argument('-c', '--config', dest='config_path', action='store', default=DEFAULT_CONFIG_FILE,
                    help='path to non-default config file')
parser.add_argument('-d', '--debug', dest='debug', action='store_true', default=False,
                    help='debug mode')
parser.add_argument('-l', '--loop', dest='loop', action='store', type=int, default=-1,
                    help='Loop forever, sleeping <int> seconds between passes. ' +
                         'If > 0 then overrides config "sample_interval" settings')
parser.add_argument('action', nargs='?', default='', help='non-default action name to run')

ARGS = parser.parse_args()

CONFIG = load_config(ARGS.config_path)

# mqtt sender script tend to hang up (why no SIGPIPE on stdin read?) if we exit hastily.
# Try to avoid this.
signal.signal(signal.SIGINT, handle_termination)
signal.signal(signal.SIGTERM, handle_termination)

hba = socket.gethostbyaddr(socket.gethostname())
hostname = re.sub(r'\..+', '', hba[0])

Sender = KMQTT(CONFIG['sender'], True, ARGS.debug)

if ARGS.debug:
    if not Sender:
        sys.exit(1)

Dates_json = ''  # will hold reusable date/timestamp JSON
queue = []  # action list to run through
stats_vf = {}  # statistics about voltage and frequency

# pre-caching the list of items to put in the log
log_items: list[str] = []
if 'log_items' in CONFIG:
    log_items.extend(CONFIG.get('log_items').split())

##################################
# set necessary defaults
if 'sample_interval' not in CONFIG:
    if ARGS.loop > 0:
        CONFIG['sample_interval'] = str(ARGS.loop)
    else:
        CONFIG['sample_interval'] = '60'  # seconds

if 'report_interval' not in CONFIG:
    CONFIG['report_interval'] = CONFIG['sample_interval']

##################################
# Which functions should we run. default is check_nut
if ARGS.action != '':
    queue.append(ARGS.action)
else:
    queue = [check_nut]

problems = False
# pre-initializing device data for NUT interface
if 'check_nut' in queue:
    if 'devices' in CONFIG:
        dev_list = CONFIG['devices'].split()
    else:
        if ARGS.debug:
            print('requesting the list of devices from upsc')

        upsc = subprocess.Popen(['upsc', '-l'],
                                stdin=subprocess.DEVNULL, stdout=subprocess.PIPE,
                                stderr=(None if ARGS.debug else subprocess.DEVNULL), text=True)
        dev_list = upsc.communicate()[0].splitlines()

    for device in dev_list:
        if not device_init(device):
            problems = True

while not problems:  # main loop
    Dates_json = '{ "date":"' + time.ctime() + '", "timestamp":' + str(int(time.time())) + ' }'
    Dates_json = Dates_json.replace(r'"', r'\"')

    for func in queue:
        if not func():
            problems = True
            break

    if problems:
        break

    if int(CONFIG['sample_interval']) <= 0:
        break

    time.sleep(int(CONFIG['sample_interval']))

# end of the main loop - finalizing
Sender.terminate()

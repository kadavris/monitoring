#!/bin/python
"""
This is a companion for the mikrotik2mqtt service which collects router performance data
and pushes it to the mqtt agent.
Now, this script is made to automatically create appropriate sensor definitions
for Home Assistant according to mikrotik2mqtt configuration.

Copyright by Andrej Pakhutin (pakhutin <at> gmail)
FOSS: http://github.com/kadavris/monitoring
License: see accompanying LICENSE file

Running:
1) Consult https://www.home-assistant.io/integrations/sensor.mqtt/#new_format
2) Apply the following configuration.yaml settings:
--- CUT HERE ---
mqtt:
  sensor: !include_dir_merge_list inc/mqtt/sensor
sensor: !include_dir_merge_list inc/sensor/
--- CUT HERE ---
3) Put this script into HA config folder, run it.
4) Check content in the folders from the 2nd step
"""
import configparser
import os
import re
import sys
import typing


# --- Helper Functions ---
def get_config_key(in_config: configparser, section: configparser, key: str) -> str:
    """
    Get a key from the (.ini) config, checking the specific section
    first, then the DEFAULT section.
    :return key value: str. '': if not found
    """
    if section in in_config and key in in_config[section]:
        return in_config[section][key]
    elif 'DEFAULT' in in_config and key in in_config['DEFAULT']:
        return in_config['DEFAULT'][key]
    return ''


def make_full_topic_path(in_config: configparser, section: configparser, topic_key: str) -> str:
    """
    Construct the full MQTT topic path for a given topic key.
    :return topic_name: str
    """
    topic_base = get_config_key(in_config, section, 'topic_root')
    if not topic_base:
        raise ValueError(f"Missing 'topic_root' key for section '{section}'")

    topic_suffix = get_config_key(in_config, section, topic_key)
    if not topic_suffix:
        raise ValueError(f"Missing or empty topic key: section: '{section}', key: '{topic_key}'")

    return f"{topic_base}/{topic_suffix}"


def make_scaled_sensor_attr(config: configparser, out_file: typing.TextIO, sensor_name: str, attr: str,
                            default_unit: str, cfgkey: str) -> str:
    """
    In place, generates the value_template and unit for scaled sensors (bytes, packets).
    :param config: config class
    :param out_file: output file
    :param sensor_name: virtual sensor: router's data
    :param attr: attribute name to the sensor
    :param default_unit: fallback unit to use: 1 letter for 1000s, 2 letter codes for 1024
    :param cfgkey: key to query for unit
    :return unit name
    """
    factors = {
        'B': 1, 'KB': 1024, 'MB': 1024*1024, 'GB': 1024*1024*1024, 'TB': 1024*1024*1024*1024,
        'K': 1000, 'M': 1000 * 1000, 'G': 1000 * 1000 * 1000, 'T': 1000 * 1000 * 1000 * 1000
    }

    new_unit = default_unit.upper()

    if 'DEFAULT' in config and cfgkey in config['DEFAULT']:
        new_unit = config['DEFAULT'][cfgkey].upper()

    factor_value = factors.get(new_unit, 0)
    if not factor_value:
        print(f'ERROR: bogus unit ({new_unit})in call to make_scaled_sensor_attr. defaulting to 1')
        factor_value = 1

    out_file.write(f'  value_template: "{{{{(float(state_attr(\'sensor.{sensor_name}\', \'{attr}\'))')
    if factor_value > 1:
        out_file.write(f'/{float(factor_value)}')
    out_file.write(')|round(3)}}"\n')

    if '-speed' in attr:
        new_unit += '/s'

    return new_unit


#######################################################################
# --- Main Logic ---
script_config = configparser.ConfigParser()
try:
    script_config.read('mikrotik2mqtt-ha-yaml-generator.ini', encoding='utf8')
except Exception as e:
    print(f"Error reading mikrotik-yaml-generator.ini: {e}", file=sys.stderr)
    sys.exit(1)

# Define output file paths
yaml_mqtt_dir = script_config['DEFAULT'].get('yaml_mqtt_dir', 'inc/mqtt/sensor/')
yaml_template_dir = script_config['DEFAULT'].get('yaml_template_dir', 'inc/template/')

# Ensure directories exist
os.makedirs(yaml_mqtt_dir, exist_ok=True)
os.makedirs(yaml_template_dir, exist_ok=True)

m2mq_ini_path = script_config['DEFAULT'].get('service_ini')
if not m2mq_ini_path:
    print("Error: 'service_ini' key not found in the default section of mikrotik-yaml-generator.ini", file=sys.stderr)
    sys.exit(1)

m2mq_config = configparser.ConfigParser()
try:
    m2mq_config.read(m2mq_ini_path, encoding='utf8')
except Exception as e:
    print(f"Error reading mikrotik2mqtt config file ('{m2mq_ini_path}'): {e}", file=sys.stderr)
    sys.exit(1)

# --- General Headers for generated YAML files ---
separator = "\n#------------------------------------------------\n"
header = """#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# WARNING: This file was generated automatically by a script
# Do not edit manually!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# NOTE: This file is included from the main configuration's .yaml by the statement:
"""
print("Generating:")

# Iterate through routers in the mikrotik2mqtt config
for host in m2mq_config.sections():
    if host == 'DEFAULT':
        continue

    host_lower = host.lower()
    print(f"\n{host}: ", end='')

    disabled = get_config_key(m2mq_config, host, 'disable').lower()
    if disabled and disabled != 'false':
        print("DISABLED")
        continue

    yaml_mqtt_file = os.path.join(yaml_mqtt_dir, f"mqtt-sensor-mikrotik-{host_lower}-autogen.yaml")
    yaml_template_file = os.path.join(yaml_template_dir, f"template-mikrotik-{host_lower}-autogen.yaml")

    try:
        with open(yaml_mqtt_file, 'w') as yaml_mqtt_h, \
             open(yaml_template_file, 'w') as yaml_template_h:

            # Write headers and host-specific separators
            yaml_mqtt_h.write(header + f"# mqtt:\n#   sensor: !include_dir_merge_list {yaml_mqtt_dir}\n\n")
            yaml_template_h.write(header + f"# template: !include_dir_merge_list {yaml_template_dir}\n\n")

            yaml_mqtt_h.write(separator + f"# host: {host_lower}" + separator)
            yaml_template_h.write(separator + f"# host: {host_lower}" + separator)

            # --- General Data (State, Last Update, Temp, Voltage, Upgrades) ---
            yaml_mqtt_h.write(f"""
- name: "{host_lower}: state"
  state_topic: "{get_config_key(m2mq_config, host, 'topic_root')}"

# data freshness
- name: "{host_lower}: last update"
  state_topic: "{get_config_key(m2mq_config, host, 'topic_root')}/updated"
  json_attributes_topic: "{get_config_key(m2mq_config, host, 'topic_root')}/updated"
  value_template: "{{{{ value_json.timestamp }}}}"

- name: "{host_lower}: temperature"
  state_topic: "{make_full_topic_path(m2mq_config, host, 'topic_temperature')}"
  unit_of_measurement: 'Â°C'
  device_class: temperature

- name: "{host_lower}: PSU voltage"
  state_topic: "{make_full_topic_path(m2mq_config, host, 'topic_voltage')}"
  unit_of_measurement: 'V'
  device_class: voltage
""")

            topic_upgrades = get_config_key(m2mq_config, host, 'topic_upgrades')
            if topic_upgrades:
                yaml_mqtt_h.write(f"""
- name: "{host_lower}: upgrades available"
  state_topic: "{make_full_topic_path(m2mq_config, host, 'topic_upgrades')}"
""")

            # --- Traffic Interfaces ---
            get_traffic_val = get_config_key(m2mq_config, host, 'get_traffic')
            if get_traffic_val:
                for interface in get_traffic_val.split():
                    interface_lower = interface.lower()
                    print(f" {interface}", end='')

                    topic = f"{make_full_topic_path(m2mq_config, host, 'topic_traffic')}/{interface_lower}"
                    state_topic = f"{topic}/state"

                    yaml_mqtt_h.write(f"""
- name: "{host_lower}: {interface_lower}"
  state_topic: "{state_topic}"
  json_attributes_topic: "{topic}"
""")

                    traffic_entities_val = script_config['DEFAULT'].get('traffic_entities', '').split()
                    for traffic_ent in traffic_entities_val:
                        main_sensor = re.sub(r'\W+', '_', f"{host_lower}_{interface_lower}").lower()
                        name = f"{host_lower}: {interface_lower}: {traffic_ent}"

                        yaml_mqtt_h.write(f"""
- name: "{name}"
  state_topic: "{state_topic}"
  json_attributes_topic: "{topic}"
""")

                        if '-byte' in traffic_ent:
                            unit = make_scaled_sensor_attr(script_config, yaml_mqtt_h, main_sensor, traffic_ent, 'B',
                                                           'traffic_scale_byte')
                            yaml_mqtt_h.write(f'  unit_of_measurement: "{unit}"\n')
                            if '-speed' in traffic_ent:
                                yaml_mqtt_h.write("  device_class: data_rate\n  state_class: measurement\n")
                            else:
                                yaml_mqtt_h.write("  device_class: data_size\n  state_class: total_increasing\n")
                        elif '-packet' in traffic_ent:
                            yaml_mqtt_h.write(f'  value_template: "{{{{ state_attr( \'sensor.{main_sensor}\', \'{traffic_ent}\' ) }}}}"\n')

                            if '-speed' in traffic_ent:
                                yaml_mqtt_h.write("  device_class: data_rate\n  state_class: measurement\n")
                                yaml_mqtt_h.write("  unit_of_measurement: \"Packets/s\"\n")
                            else:
                                yaml_mqtt_h.write("  device_class: data_size\n  state_class: total_increasing\n")
                                yaml_mqtt_h.write("  unit_of_measurement: \"Packets\"\n")
                            yaml_mqtt_h.write("  icon: \"mdi:train-car-container\"\n")
                        elif '-error' in traffic_ent or '-drop' in traffic_ent or 'link-downs' in traffic_ent:
                            counters_icon_good = script_config['DEFAULT'].get('counters_icon_good', 'mdi:lan-connect')
                            counters_icon_bad = script_config['DEFAULT'].get('counters_icon_bad', 'mdi:lan-disconnect')
                            yaml_mqtt_h.write(f'  value_template: "{{{{ state_attr( \'sensor.{main_sensor}\', \'{traffic_ent}\' ) }}}}"\n')
                            yaml_mqtt_h.write('  unit_of_measurement: "Count"\n')  # ugly, but what else?
                            yaml_mqtt_h.write("  state_class: measurement\n")
                            yaml_mqtt_h.write("  icon: >\n")
                            yaml_mqtt_h.write("    {% if value == 0 %}\n")
                            yaml_mqtt_h.write(f"      {counters_icon_good}\n")
                            yaml_mqtt_h.write("    {% else %}\n")
                            yaml_mqtt_h.write(f"      {counters_icon_bad}\n")
                            yaml_mqtt_h.write("    {% endif %}\n")
                        else:
                            yaml_mqtt_h.write(f'  value_template: "{{{{ state_attr( \'sensor.{main_sensor}\', \'{traffic_ent}\' ) }}}}"\n')
                            yaml_mqtt_h.write(f'  state_class: measurement\n')

            # --- Firewall Stats by ID ---
            fw_topic_id = get_config_key(m2mq_config, host, 'get_firewall_by_id')
            if fw_topic_id:
                print(" Firewall by STATID", end='')
                yaml_mqtt_h.write(f"{separator}# Firewall section:{separator}")

                fw_topic_base = make_full_topic_path(m2mq_config, host, 'get_firewall_by_id')
                fw_state_topic = f"{fw_topic_base}/state"

                yaml_mqtt_h.write(f'\n- name: "{host_lower}: Firewall stats by id"\n')
                yaml_mqtt_h.write(f'  state_topic: "{fw_state_topic}"\n')
                yaml_mqtt_h.write(f'  json_attributes_topic: "{fw_topic_base}"\n')

                main_sensor_fw = re.sub(r'\W+', '_', f"{host_lower}_firewall_stats_by_id").lower()
                firewall_by_id_fields = script_config['DEFAULT'].get('firewall_by_id', '').split()
                for field in firewall_by_id_fields:
                    for unit in ('bytes', 'packets'):
                        for delta in ('', '-delta'):
                            entity = field + '-' + unit + delta
                            yaml_mqtt_h.write(f'\n- name: "{host_lower}: firewall: {entity}"\n')
                            yaml_mqtt_h.write(f'  state_topic: "{fw_state_topic}"\n')
                            yaml_mqtt_h.write(f'  json_attributes_topic: "{fw_topic_base}"\n')

                            if unit == 'bytes':
                                unit_bytes = make_scaled_sensor_attr(script_config, yaml_mqtt_h, main_sensor_fw, entity, 'B', 'traffic_scale_byte')
                                yaml_mqtt_h.write(f'  device_class: data_size\n  unit_of_measurement: "{unit_bytes}"\n')
                            else:
                                yaml_mqtt_h.write(f'  value_template: "{{{{ state_attr( \'sensor.{main_sensor_fw}\', \'{entity}\' ) }}}}"\n')
                                yaml_mqtt_h.write(f'  unit_of_measurement: "Packets"\n')
                                yaml_mqtt_h.write('  icon: "mdi:train-car-container"\n')

                            yaml_mqtt_h.write("  state_class: measurement\n")

                yaml_mqtt_h.write(f"{separator}")

            # --- General Sensor Definitions and Helpers (Home Assistant Template Sensors) ---
            overheat_temp = script_config['DEFAULT'].get('overheat', '60')  # Default overheat
            yaml_template_h.write(f"""
- sensor:
  - default_entity_id: sensor.{host_lower}_freshness
    name: "{host_lower}: data freshness check"
    state: >-
      {{% set topic_u = 'sensor.{host_lower}_last_update' %}}
      {{% if states( topic_u ) == 'unknown' %}}
        NO DATA!
      {{% elif as_timestamp(now()) - ( states( topic_u )|float ) > 1800 %}}
        OLD: {{{{ state_attr( topic_u, 'date' ) }}}}
      {{% else %}}
        OK
      {{% endif %}}

    icon: >-
      {{% set topic_u = 'sensor.{host_lower}_last_update' %}}
      {{% if states( topic_u ) == 'unknown' %}}
        mdi:database-remove-outline
      {{% elif as_timestamp(now()) - ( states( topic_u )|float ) > 1800 %}}
        mdi:disc-alert
      {{% else %}}
        mdi:harddisk
      {{% endif %}}

- sensor:
  - default_entity_id: sensor.{host_lower}_problems
    name: "{host_lower}: problems"
    state: >-
      {{% if states( 'sensor.{host_lower}_freshness' ) != "OK" %}}
        {{{{ states( 'sensor.{host_lower}_freshness' ) }}}}
      {{% else %}}
        {{% if states( 'sensor.{host_lower}_temperature' ) != 'unknown' %}}
          {{% if states( 'sensor.{host_lower}_temperature' )|float > {overheat_temp} %}}
            OVERHEATING: {{{{ states( 'sensor.{host_lower}_temperature' ) }}}}
            ( {{{{ states( 'sensor.{host_lower}' ) }}}} )
          {{% endif %}}
        {{% endif %}}
      {{% endif %}}
""")

    except IOError as e:
        print(f"Error opening file for {host_lower}: {e}", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        print(f"An unexpected error occurred for {host_lower}: {e}", file=sys.stderr)
        sys.exit(1)

print("\n")

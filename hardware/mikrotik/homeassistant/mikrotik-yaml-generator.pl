#!/bin/perl
use warnings;
use strict;
use Config::Tiny;
# This is companion for mikrotik2mqtt script
# that queries router for various data and pushes it to the mqtt agent.
# Now this script is made for automatically create sensor definition for Home Assistant
# using mikrotik2mqtt configuration.
# Copyright by Andrej Pakhutin (pakhutin <at> gmail)
# http://github.com/kadavris/monitoring
# License: see accompanying LICENSE file

# https://www.home-assistant.io/integrations/sensor.mqtt/#new_format
# Put this script into HA config folder.
# Use with the following configuration.yaml settings:
#mqtt:
#  sensor: !include_dir_merge_list inc/mqtt/sensor
#sensor: !include_dir_merge_list inc/sensor/

##################################################
# MAIN
# Open the config
my $config = Config::Tiny->read( 'mikrotik-yaml-generator.ini', 'utf8' );
defined($config) or die("own .ini problem!");

my $m2mq_config = Config::Tiny->read( $config->{_}->{ 'ini' }, 'utf8' );
defined($m2mq_config) or die("m2q .ini problem!");

for my $host ( keys( %$m2mq_config ) )
{
    next if $host eq 'DEFAULT';
    $host = lc($host);
    print "\n$host: ";
    my $disabled = lc(get_m2mq_key($host, 'disable'));  # disable = true
    if ( $disabled ne '' && $disabled ne 'false' )
    {
        print "DISABLED\n";
        continue;
    }

    my $yaml_mqtt_file = "inc/mqtt/sensor/mqtt-sensor-mikrotik-$host-autogen.yaml";
    my $yaml_sensors_file = "inc/sensor/sensor-mikrotik-$host-autogen.yaml";

    if ( 0 )#-f $yaml_mqtt_file )
    {
        print "File $yaml_mqtt_file already exists. Overwrite (y/N)? ";

        my $a = <STDIN>;
        chomp $a;

        if ( lc($a) ne 'y' )
        {
            exit 0;
        }
    }

    open( my $yaml_mqtt_h, '>', $yaml_mqtt_file ) or die "$yaml_mqtt_file: $!";
    open( my $yaml_sensors_h, '>', $yaml_sensors_file ) or die "$yaml_sensors_file: $!";

    print "Generating:";

    my $separator = "\n#------------------------------------------------\n";

    my $header = q~#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# WARNING: This file was generated automatically by mikrotik-yaml-generator.pl
# Do not edit manually!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# NOTE: This file is included from the main configuration.yaml by the statement:
~;

    print $yaml_mqtt_h $header, "# mqtt:\n#   sensor: !include_dir_merge_list inc/mqtt/sensor\n\n";
    print $yaml_sensors_h $header, "# sensor: !include_dir_merge_list inc/sensor/\n\n";

    print $yaml_mqtt_h $separator, "# host: $host", $separator;
    print $yaml_sensors_h $separator, "# host: $host", $separator;

    # mikrotik2mqtt .ini interesting keys:
    # topic_upgrades
    # topic_temperature
    # topic_voltage
    # topic_traffic
    # topic_root
    # get_traffic
    # updated

    # putting general data first
    print $yaml_mqtt_h qq~
- name: "$host: state"
  state_topic: "~, get_m2mq_key($host, 'topic_root'), qq~"

# data freshness
- name: "$host: last update"
  state_topic: "~, get_m2mq_key($host, 'topic_root') . '/updated', qq~"
  json_attributes_topic: "~, get_m2mq_key($host, 'topic_root') . '/updated', qq~"
  value_template: "{{ value_json.timestamp }}"

- name: "$host: temperature"
  state_topic: "~, make_full_topic_path($host, 'topic_temperature'), qq~"
  unit_of_measurement: 'Â°C'
  device_class: temperature

- name: "$host: PSU voltage"
  state_topic: "~, make_full_topic_path($host, 'topic_voltage'), qq~"
  unit_of_measurement: 'V'
  device_class: voltage
~;

    my $topic_upgrades = get_m2mq_key($host, 'topic_upgrades');

    if ( $topic_upgrades ne '' )
    {
        print $yaml_mqtt_h "\n- name: \"$host: upgrades available\"\n",
            "  state_topic: \"", make_full_topic_path($host, 'topic_upgrades'), "\n";
    }

    for my $interface ( split(/\s+/, get_m2mq_key($host, 'get_traffic') ) )
    {
        $interface = lc($interface);
        print " $interface";

        my $topic = make_full_topic_path($host, 'topic_traffic') . '/' . $interface;

        print $yaml_mqtt_h qq~
- name: "${host}: $interface"
  state_topic: "$topic"
  json_attributes_topic: "$topic"
~;
        # what we want to see from the interface
        for my $traffic_ent ( split(/\s+/, $config->{_}->{'traffic_entities'}) )
        {
            my $sensor = lc("${host}_${interface}");
            $sensor =~ s/\W+/_/g;
            print $yaml_mqtt_h qq~
- name: "${host}: $interface: $traffic_ent"
  state_topic: "$topic"
  json_attributes_topic: "$topic"
~;
            if ( grep( /^$traffic_ent$/, qw~rx-byte tx-byte fp-rx-byte fp-tx-byte~) )
            {
                my $unit = make_scaled_sensor_attr($sensor, $traffic_ent, 'B', 'traffic_scale_byte', $yaml_mqtt_h);
                print $yaml_mqtt_h "  device_class: data_size\n  unit_of_measurement: \"$unit\"\n";
                print $yaml_mqtt_h "  state_class: total_increasing\n";
            }
            elsif ( grep( /^$traffic_ent$/, qw~rx-packet tx-packet fp-rx-packet fp-tx-packet~ ))
            {
                print $yaml_mqtt_h qq~  value_template: "{{ state_attr( 'sensor.$sensor', '$traffic_ent' ) }}"\n~;
                print $yaml_mqtt_h "  unit_of_measurement: \"Packets\"\n";
                print $yaml_mqtt_h "  state_class: total_increasing\n";
            }
            elsif ( $traffic_ent =~ /delta$/ )
            {
                my $unit = make_scaled_sensor_attr($sensor, $traffic_ent, 'B', 'traffic_scale_byte', $yaml_mqtt_h);
                print $yaml_mqtt_h qq~  state_class: measurement\n~;
                print $yaml_mqtt_h qq~  device_class: data_size\n  unit_of_measurement: "$unit"\n~;
            }
            else
            {
                print $yaml_mqtt_h qq~  value_template: "{{ state_attr( 'sensor.$sensor', '$traffic_ent' ) }}"\n~;
                print $yaml_mqtt_h qq~  state_class: measurement\n~;
            }

            #rx-error tx-error link-downs
            #rx-drop tx-drop tx-queue-drop
            #'last-link-up-time'
        } # for my $traffic_ent
    } # for my $interface (get_traffic)
    
    # -------------------------------------------------
    # Firewall:
    my $fw_topic = get_m2mq_key($host, 'get_firewall_by_id');
    if ( $fw_topic ne '' )
    {
        print " Firewall by STATID";

        print $yaml_mqtt_h "$separator# Firewall section:\n";

        $fw_topic = make_full_topic_path($host, 'get_firewall_by_id');

        print $yaml_mqtt_h "- name: \"$host: Firewall stats by id\"\n", # fix $sensor if chnged!
            "  state_topic: \"$fw_topic\"\n",
            "  json_attributes_topic: \"$fw_topic\"\n";

        my $sensor = lc("${host}_firewall_stats_by_id");
        $sensor =~ s/\W+/_/g;

        # generating entities derived from json
        for my $field (split(/\s+/, $config->{_}->{'firewall_by_id'}))
        {
            my $entity = $field . '-bytes';
            print $yaml_mqtt_h qq~\n- name: "${host}: firewall: $entity"\n~,
                "  state_topic: \"$fw_topic\"\n",
                "  json_attributes_topic: \"$fw_topic\"\n";

            my $unit = make_scaled_sensor_attr($sensor, $entity, 'B', 'traffic_scale_byte', $yaml_mqtt_h);
            print $yaml_mqtt_h "  device_class: data_size\n  unit_of_measurement: \"$unit\"\n";
            print $yaml_mqtt_h "  state_class: measurement\n";

            $entity = $field . '-packets';
            print $yaml_mqtt_h qq~- name: "${host}: firewall: $entity"\n~,
                "  state_topic: \"$fw_topic\"\n",
                "  json_attributes_topic: \"$fw_topic\"\n";

            print $yaml_mqtt_h qq~  value_template: "{{ state_attr( 'sensor.$sensor', '$entity' ) }}"\n~;
            print $yaml_mqtt_h "  device_class: data_size\n";
            # Make it "PB" so the statistics widget will be happy... or I'm choosing the wrong card again?...
            print $yaml_mqtt_h "  unit_of_measurement: \"PB\"\n";
            print $yaml_mqtt_h "  state_class: measurement\n";
        }

        print $yaml_mqtt_h "$separator"
    }

    # -------------------------------------------------
    # General sensor definitions and helpers:

    # NOTE:
    # There is expire_after <seconds> attribute for mqtt sensor
    # that we can use to check if data is fresh: state will be 'unavailable' if stale
    print $yaml_sensors_h qq~
- platform: template
  sensors:
    ${host}_freshness:
      friendly_name: "$host: data freshness check"
      value_template: >-
        {% set topic_u = 'sensor.${host}_last_update' %}
        {% if states( topic_u ) == 'unknown' %}
          NO DATA!
        {% elif as_timestamp(now()) - ( states( topic_u )|float ) > 1800 %}
          OLD: {{ state_attr( topic_u, 'date' ) }}
        {% else %}
          OK
        {% endif %}

      icon_template: >-
        {% set topic_u = 'sensor.${host}_last_update' %}
        {% if states( topic_u ) == 'unknown' %}
          mdi:database-remove-outline
        {% elif as_timestamp(now()) - ( states( topic_u )|float ) > 1800 %}
          mdi:disc-alert
        {% else %}
          mdi:harddisk
        {% endif %}

- platform: template
  sensors:
    ${host}_problems:
      friendly_name: "${host}: problems"
      value_template: >-
        {% if states( 'sensor.${host}_freshness' ) != "OK" %}
          {{ states( 'sensor.${host}_freshness' ) }}
        {% else %}
          {% if states( 'sensor.${host}_temperature' ) != 'unknown' %}
            {% if states( 'sensor.${host}_temperature' )|float > ~, $config->{_}->{'overheat'}, qq~ %}
              OVERHEATING: {{ states( 'sensor.${host}_temperature' ) }}
              ( {{ states( 'sensor.${host}' ) }} )
            {% endif %}
          {% endif %}
        {% endif %}
~;
    close($yaml_mqtt_h);
    close($yaml_sensors_h);
} # for my $host

print "\n";

##################################################
sub make_scaled_sensor_attr
{
    my ($sensor, $attr, $unit, $cfgkey, $file) = @_;

    my %factors = ( 'KB'=>1024, 'MB'=>1024*1024, 'GB'=>1024*1024*1024, 'TB'=>1024*1024*1024*1024 );

    print $file qq~  value_template: "{{ float(state_attr( 'sensor.$sensor', '$attr' )~;
    if ( defined($config->{_}->{$cfgkey} ) )
    {
        $unit = uc($config->{_}->{$cfgkey});
        print $file ' / ', $factors{ $unit };
    }
    print $file qq~,3) }}"\n~;
    return $unit;
}

##################################################
# get mikrotik2mqtt config key, minding the DEFAULT section
# params: section, key
sub get_m2mq_key
{
    my ($section, $key) = @_;
    if( defined( $m2mq_config->{$section}->{$key} ) )
    {
        return $m2mq_config->{$section}->{$key};
    }
    elsif (defined( $m2mq_config->{'DEFAULT'}->{$key} ))
    {
        return $m2mq_config->{'DEFAULT'}->{$key};
    }
    return '';
}

##################################################
# construct full mqtt topic for the config key, minding the DEFAULT section
# params: section, topic_key
sub make_full_topic_path
{
    my ($section, $topic_key) = @_;
    my $t = get_m2mq_key($section, $topic_key);
    if ($t eq '')
    {
        die("make_full_topic_path() invalid topic variable: sec: '", $section, "', tkey: '", $topic_key, "'")
    }

    return get_m2mq_key($section, 'topic_root') . '/' . $t;
}
